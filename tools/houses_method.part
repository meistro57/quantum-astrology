public static function houses(\DateTimeImmutable $utc, float $lat, float $lon, string $houseSystem = "P"): array
{
    $date = $utc->format("d.m.Y");
    $time = $utc->format("H:i:s");
    $hs   = strtoupper($houseSystem[0] ?? "P");

    // swetest expects lon,lat,hsys; requires -ut for houses
    $args = sprintf(
        '-eswe -b%s -ut%s -house%F,%F,%s -g, -head',
        escapeshellarg($date),
        escapeshellarg($time),
        $lon,  // east positive
        $lat,  // north positive
        escapeshellarg(strtolower($hs))
    );

    $lines = self::run($args);

    // Collect only angles (0..360)
    $a = [];
    foreach ($lines as $line) {
        if (preg_match_all('/-?\d+(?:\.\d+)?/', $line, $m)) {
            foreach ($m[0] as $raw) {
                $v = self::norm360((float)$raw);
                if ($v >= 0.0 && $v < 360.0) $a[] = $v;
            }
        }
    }
    if (count($a) < 16) {
        throw new \RuntimeException('Could not parse enough values for houses.');
    }

    // Heuristic #1: use the last block (12 cusps + angles)
    $block = count($a) >= 20 ? array_slice($a, -20) : array_slice($a, -16);
    $cusps = array_slice($block, 0, 12);
    $anglesOut = [
        'ASC'    => $block[12] ?? 0.0,
        'MC'     => $block[13] ?? 0.0,
        'ARMC'   => $block[14] ?? 0.0,
        'Vertex' => $block[15] ?? 0.0,
    ];
    $eps = 0.8; // degrees tolerance

    $mcMatches  = self::delta($anglesOut['MC'], $cusps[9] ?? -999) <= $eps;   // cusp10
    $ascMatches = self::delta($anglesOut['ASC'], $cusps[0] ?? -999) <= $eps;  // cusp1

    // If not aligned, search the whole stream for a 12+4 window that aligns ASC with cusp1 and MC with cusp10.
    if (!$mcMatches || !$ascMatches) {
        $best = null;
        for ($i = 0; $i + 15 < count($a); $i++) {
            $winCusps  = array_slice($a, $i, 12);
            $winAngles = [
                'ASC'    => $a[$i+12],
                'MC'     => $a[$i+13],
                'ARMC'   => $a[$i+14],
                'Vertex' => $a[$i+15],
            ];
            $okAsc = self::delta($winAngles['ASC'], $winCusps[0]) <= $eps;
            $okMC  = self::delta($winAngles['MC'],  $winCusps[9]) <= $eps;
            if ($okAsc && $okMC) { $best = [$winCusps, $winAngles]; break; }
        }
        if ($best) {
            [$cusps, $anglesOut] = $best;
        } else {
            // Last resort in Placidus: force cusp1/10 to ASC/MC so visuals stay correct
            if ($hs === 'P') {
                $cusps[0] = $anglesOut['ASC'];
                $cusps[9] = $anglesOut['MC'];
            }
        }
    }

    // Map to 1..12 and normalise
    $outCusps = [];
    for ($k=0; $k<12; $k++) $outCusps[$k+1] = self::norm360($cusps[$k]);

    return [
        'system' => $hs,
        'cusps'  => $outCusps,
        'angles' => [
            'ASC'    => self::norm360($anglesOut['ASC']),
            'MC'     => self::norm360($anglesOut['MC']),
            'ARMC'   => self::norm360($anglesOut['ARMC']),
            'Vertex' => self::norm360($anglesOut['Vertex']),
        ],
    ];
}
